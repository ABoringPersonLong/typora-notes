```
1.阶段目标：
    1.使用字体图标、平面转换、动画等 C3 属性丰富网页效果和呈现方式
    2.能够开发移动端网页
2.CSS3：
    1.目标：
        使用平面转换和动画属性，丰富网页元素
        呈现方式和效果
    2.字体图标 iconfont：
        简单使用：
            1.导入 iconfont 图标库
            2.引入 <link rel="stylesheet" href="./iconfont/iconfont.css">
            3.添加 iconfont 类和字体图标的类名
        上传矢量图：
            如果图标库没有项目所需的图标怎么办？
                IconFont 网站上传矢量图生成字体图标
                    1.与设计师沟通，得到 SVG 矢量图
                    2.去 iconfont.cn 网站上传 SVG 图标文件
                    3.去资源管理，把上传的图标全部加入购物车
                    4.去购物车加入项目，没有就创建一个项目
                    5.去我的项目下载至本地
    3.平面转换：
        使用 transform 属性实现元素的位移、旋转、缩放等效果
        1.平面转换：
            改变盒子在平面内的形态（位移、旋转、缩放）
            2D 转换
        2.位移：
            1.语法：
                transform: translate(水平移动距离，垂直移动距离);
            2.取值（正负均可）：
                像素单位数值
                百分比（参照物为盒子自身尺寸）
                注意：x 轴正向为向右移动，y 轴正向为向下移动
            3.技巧：
                translate() 如果只给出一个值，表示 x 轴方向移动距离
                单独设置某个方向的移动距离：translateX() 和 translateY()
        3.旋转：
            1.旋转：
                语法：
                    transform: rotate(角度);
                    注意：角度单位是 deg
                技巧：
                    取值正负均可
            2.转换原点：
                默认原点是盒子中心点
                语法：
                    transform-origin: 原点水平位置 原点垂直位置
                取值：
                    方位名词（left、right、top、bottom、center）
                    像素单位数值
                    百分比（参照物为盒子自身尺寸）
            3.多重转换：
                语法：
                    transform-origin: 原点水平位置 原点垂直位置
        4.缩放：
            改变元素的 width 或 height 属性能实现吗？
            语法：
                transform: scale(x轴缩放倍数, y轴缩放倍数)
            技巧：
                一般情况下，只为 scale 设置一个值，表示 x 轴和 y 轴等比例缩放
                transform: scale(缩放倍数, 缩放倍数)
    4.渐变：
        渐变是多个颜色逐渐变化的视觉效果
        一般用于设置盒子的背景
        语法：
            background-image: linear-gradient(
                颜色1,
                颜色2,
                ...
            );
    5.空间转换：
        空间：是从坐标轴角度定义的。x、y 和 z 三条坐标轴构成了一个立体空间，z 轴位置与视线方向相同
        空间转换也叫 3D 转换
        属性：transform
        1.空间位移：
            使用 translate 实现元素空间位移效果
            语法：
                transform: translate3d(x, y, z);
                transform: translateX(值);
                transform: translateY(值);
                transform: translateZ(值);
            取值（正负均可）：
                像素单位数值
                百分比
        2.透视：
            使用 perspective 属性实现透视效果
            思考：
                生活中，同一个物体，观察距离不同，视觉上有什么区别？
                    近大远小，近清楚远模糊
            思考：
                默认情况下，为什么无法观察到 z 轴位移效果？
                    z 轴是视线方向，移动效果应该是距离的远或近，电脑屏幕是平面，默认无法观察远近效果
            语法（添加给父级）：
                perspective: 值;
            取值：
                像素单位数值，数值一般在 800 ~ 1200
                透视距离也称为视距，所谓的视距就是人的眼睛到屏幕的距离
        3.空间旋转：
            使用 rotate 实现元素空间旋转效果
            语法：
                transform: rotateZ(值);
                transform: rotateX(值);
                transform: rotateY(值);
            拓展：
                transform: rotate3d(x, y, z, 角度度数);
                用来设置自定义旋转轴的位置及旋转的角度
                x, y, z 取值为 0-1 之间的数字
        4.立体呈现：
            使用 transform-style: preserve-3d 呈现立体图形
            实现方法：
                添加 transform-style: preserve-3d; 使子元素处于正真的 3d 空间
                默认值 flat，表示子元素处于 2D 平面内呈现
        5.空间缩放：
            使用 scale 实现空间缩放效果
            语法：
                transform: scaleX(倍数);
                transform: scaleY(倍数);
                transform: scaleZ(倍数);
                transform: scale3d(x, y, z);
        6.空间扭曲：
            transform: skew();
    6.动画：
        动画：
            使用 animation 添加动画效果
            思考：
                过渡可以实现什么效果？
                    实现 2 个状态间的变化过程
            动画效果：
                实现多个状态间的变化过程，动画过程可控（重复播放、最终画面、是否暂停）
                动画的本质是快速切换大量图片时在人脑中形成的具有连续性的画面
                构成动画的最小单元：帧或动画帧
            1.实现步骤：
                1.定义动画：
                    第一种：
                        @keyframes 动画名称 {
                            from {}
                            to {}
                        }
                    第二种：
                        @keyframes 动画名称 {
                            0% {}
                            10% {}
                            15% {}
                            100% {}
                        }
                2.使用动画：
                    animation: 动画名称 动画花费时长;
        动画属性：
            使用 animation 相关属性控制动画执行过程
            语法：
                animation: 动画名称 动画时长 速度曲线 延迟时间 重复次数 动画方向 执行完毕时状态;
            注意：
                动画名称和动画时长必须赋值
                取值不分先后顺序
                如果有 2 个时间值，第一个时间表示动画时长，第二个时间表示延迟时间
            animation 拆分属性：
                animation-name: 动画名称
                animation-duration: 动画时长
                animation-timing-function: 速度曲线
                animation-delay: 延迟时间
                animation-iteration-count: 重复次数
                animation-direction: 动画方向
                animation-fill-mode: 执行完毕时状态
                animation-play-state: 暂停动画
                    取值 paused，通常配合 :hover 使用
            steps 逐帧动画：
                属性：
                    animation-timing-function
                作用：
                    速度曲线
                取值：
                    steps(数字)：逐帧动画
                逐帧动画：
                    帧动画。开发中，一般配合精灵图实现动画效果
                    animation-timing-function: steps(N);
                    将动画过程等分成 N 分
                精灵动画制作步骤：
                    1.准备显示区域
                        设置盒子尺寸是一张小图的尺寸，背景图为当前精灵图
                    2.定义动画:
                        改变背景图的位置（移动的距离就是精灵图的宽度）
                    3.使用动画：
                        添加速度曲线 steps(N)，N 与精灵图上小图个数相同
                        添加无限重复效果
            多组动画：
                思考：
                    如果想让小人跑远一些，该如何实现？
                        精灵动画的同时添加盒子位移动画
                语法：
                    animation: 动画1, 动画2, ...;
3.Flex：
    1.目标：
        了解移动端与 PC 端屏幕和网页布局差异
        使用 Flex 布局模型实现网页布局
    2.移动端特点：
        1.移动端和 PC 端网页不同点：
            PC 端网页和移动端网页有什么不同？
                PC 屏幕大，网页固定版心
                手机屏幕小，网页宽度多数为 100%
        2.谷歌模拟器：
            如何在电脑里面边写代码边调试移动端网页效果？
                谷歌模拟器
    3.分辨率：
        1.屏幕尺寸：
            指的是屏幕对角线的长度，一般用英文来度量
        2.PC 端分辨率：
            1920 * 1080
            1266 * 768
            ...
            1.缩放 150%
                (1920 / 150%) * (1080 / 150%)
            2.总结：
                硬件分辨率（出厂设置）
                缩放调节的分辨率（软件设置）
            3.分辨率分类：
                物理分辨率是生产屏幕时就固定的，它是不可被改变的
                逻辑分辨率是由软件（驱动）决定的
            4.思考：
                制作网页参考物理分辨率还是逻辑分辨率？
                    逻辑分辨率
        3.移动端分辨率：
            了解移动端主流设备分辨率
            参见：移动端主流设备分辨率.png
        4.视口：
            使用 meta 标签设置视口宽度，制作适配不同设备宽度的网页
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                手机屏幕尺寸都不同，网页宽度为 100%
                网页的宽度和逻辑分辨率尺寸相同
            思考：
                默认情况下，网页的宽度和逻辑分辨率相同吗？
                    不同，默认网页宽度是 980px
        5.二倍图：
            能够使用像素大厨软件测量二倍图中元素的尺寸
            图片分辨率，为了高分辨率下图片不会模糊失真
    4.百分比布局：【参见 07-京东】
        百分比布局：也叫流式布局
        效果：宽度自适应，高度固定
    5.Flex 布局：
        1.目标：
            能够使用 Flex 布局模型灵活、快速的开发网页
        2.思考：
            1.多个盒子横向排列使用什么属性？
                浮动
            2.设置盒子间的间距使用什么属性？
                margin
            3.需要注意什么问题？
                浮动的盒子脱标
        3.Flex 布局/弹性布局：
            是一种浏览器提倡的布局模型
            布局网页更简单、灵活
            避免浮动脱标的问题
        4.Flex 布局模型构成：
            1.目标：
                能够使用 Flex 布局模型灵活、快速的开发网页
            2.作用：
                基于 Flex 精确灵活控制块级盒子的布局方式，避免浮动布局中的脱离文档流现象发生
                Flex 布局非常适合结构化布局
            3.设置方式：
                父元素添加 display: flex;，子元素可以自动的挤压或拉伸
            4.组成部分：
                参见 Flex组成部分.png
                1.弹性容器
                2.弹性盒子
                3.主轴
                4.侧轴/交叉轴
        5.主轴对齐方式：
            1.目标：
                使用 justify-content 调节元素在主轴的对齐方式
            2.思考：
                网页中，盒子之间有距离吗？
                    有。在 Flex 布局模型中，调节主轴或侧轴的对齐方式来设置盒子之间的间距
            3.修改主轴对齐方式属性：
                justify-content
                取值：
                    flex-start 默认值，从起点开始依次排列
                    flex-end 从终点开始依次排列
                    center 沿主轴居中排列
                    space-around 弹性盒子沿着主轴均匀排列，空白间距均分在弹性盒子两侧
                    space-between 弹性盒子沿着主轴均匀排列，空白间距均分在相邻盒子之间
                    space-evenly 弹性盒子沿着主轴均匀排列，弹性盒子与容器之间间距相等
        6.侧轴对齐方式：
            1.目标：
                使用 align-items 调节元素在侧轴的对齐方式
            2.修改侧轴对齐方式属性：
                align-items 控制所有弹性盒子在侧轴的对齐方式（添加到弹性容器）
                align-self 控制某个弹性盒子在侧轴的对齐方式（添加到弹性盒子）
                取值：
                    flex-start 默认值，从起点开始依次排列
                    flex-end 从终点开始依次排列
                    center 沿侧轴居中排列
                    stretch 默认值，弹性盒子沿着侧轴线被拉伸至铺满容器
        7.伸缩比：
            1.目标：
                使用 flex 属性修改弹性盒子伸缩比
            2.属性：
                flex
            3.取值分类：
                数值（整数）
            4.注意：
                只占用父盒子剩余尺寸
        8.主轴方向：
            1.目标：
                使用 flex-direction 改变元素排列方向
            2.思考：
                Flex 布局模型中，弹性盒子默认沿着哪个方向排列？
                    水平方向
            3.修改主轴方向属性：
                flex-direction
                取值：
                    row 行，水平（默认值）
                    column 列，垂直
                    row-reverse 行，从右向左
                    column-reverse 列，从下向上
        9.弹性盒子换行：
            1.目标：
                使用 flex-wrap 实现弹性盒子多行排列效果
            2.弹性盒子换行显示：
                flex-wrap: wrap;
            3.调整行对齐方式：
                align-content
                取值与 justify-content 基本相同
        10.弹性盒子子元素出现顺序：
            2.属性：
                order
            3.取值分类：
                数值（整数）
                定义排列顺序. 数值越小, 排列越靠前, 默认为 0
        11.其他属性：
            flex-grow: 如果剩余有宽度是否进行扩张方法，默认是 0
            flex-shrink: 空间不足的时候进行缩小默认是 1（进行缩小）
4.移动适配：
    1.目标：
        能够实现视口宽度不同时，网页元素宽高等比缩放效果
    2.解决方案：
        rem: 目前多数企业在用的解决方案
        vw/vh: 未来的解决方案
    3.rem：
        1.网页效果：
            屏幕宽度不同，网页元素尺寸不同（等比缩放）
        2.px 单位或百分比布局可以实现吗？
            px 单位是绝对单位
            百分比布局特点宽度自适应，高度固定
        3.rem 单位：
            相对单位
            rem 单位是相对于 HTML 标签的字号计算结果
            1rem = 1HTML 字号大小
        4.媒体查询：
            1.思考：
                手机屏幕大小不同，分辨率不同，如何设置不同的 HTML 标签字号？
                设备宽度不同，HTML 标签字号设置多少合适？
            2.媒体查询：
                媒体查询能够检测视口的宽度，然后编写差异化的 CSS 样式
                当某个条件成立，执行对应的 CSS 样式
                写法：
                    @media (媒体特性) {
                        选择器 {
                            CSS 属性
                        }
                    }
                例：
                    @media (width:375px) {
                        html {
                            font-size: 40px;
                        }
                    }
            3.适配：
                目前 rem 布局方案中，将网页等分成 10 份，HTML 标签的字号位视口宽度的 1/10
            4.布局流程：
                思考：
                    工作中，书写代码的尺寸要参照设计稿尺寸，设计稿中是 px 还是 rem？
                    如何确定 rem 的数值？
                目标：计算 68px 是多少个 rem？(假定设计稿适配 375px 视口)
                    公式：
                        N * 37.5 = 68 或 N = 68 / 37.5
                        N 是 rem 的数值，如果结果有很长的小数，取三位小数
                    1.确定设计稿对应的设备的 HTML 标签字号：
                        查看设计稿宽度 -> 确定参考设备宽度(视口宽度) -> 确定基准根字号(1/10视口宽度)
                    2.rem 单位的尺寸：
                        rem 单位的尺寸 = px 单位数值/基准根字号
        5.flexible.js：
            1.目标：
                使用 flexible.js 配合 rem 实现在不同宽度的设备中，网页元素尺寸等比例缩放效果
            2.简介：
                flexible.js 是手淘开发出的一个用来适配移动端的 js 框架
                核心原理就是根据不同的视口宽度给网页中 html 根节点设置不同的 font-size
    4.Less：
        1.简介：
            Less 是一个 CSS 预处理器，Less 文件后缀是 .less
            扩充了 CSS 语言，使 CSS 具备一定的逻辑性、计算能力
            注意：浏览器不识别 Less 代码，目前阶段，网页要引入对应的 CSS 文件
        2.Easy LESS：
            vscode 插件
            作用: less 文件保存自动生成 css 文件
        3.Less 语法：
            1.注释：
                单行注释：
                    // 注释内容
                    快捷键: ctrl + /
                块注释：
                    /* 注释内容 */
                    快捷键: shift + alt + a
            2.运算：
                加、减、乘直接书写计算机表达式即可
                除法需要添加 () 或 .
            3.嵌套：
                作用：
                    快速生成后台选择器
                语法：
                    .父级选择器 {
                        // 父级样式
                        .子级选择器 {
                            // 子级样式
                        }
                    }
                注意：
                    & 不生成后代选择器，表示当前选择器，通常配合伪类或伪元素使用
            4.变量：
                1.思考：
                    网页中，文字颜色基本都是统一的，如果网站改版，变换文字颜色，如何修改代码？
                        方法一：逐一修改属性值（太繁琐）
                        方法二：把颜色提前存储到一个容器，设置属性值为这个容器名
                2.语法：
                    定义变量: @变量名: 值;
                    使用变量：CSS属性: @变量名;
            5.导入：
                1.思考：
                    开发网站时，网页如何引入公共样式？
                        CSS: 书写 link 标签
                        Less: 导入
                2.语法：
                    @import "文件路径"
            6.导出：
                1.思考：
                    目前，Less 文件导出的 CSS 文件位置是哪里？
                        是与 less 文件相同的位置
                2.方法一：
                    配置 EasyLess 插件，实现所有 Less 有相同的导出路径
                    Settings -> 搜索 easy less configuration -> 点击 Edit in settings.json
                    添加代码以下代码：(注意必须是双引号)
                        "less.compile": {
                            "out": "../css/"
                        }
                        表示将 CSS 文件导出到 ../css/ 路径下
                3.方法二：
                    在 less 文件第一行添加: // out: ../css/
                    表示将当前 CSS 文件导出到 ../css/ 路径下
            7.禁止导出：
                1.思考：
                    所有的 Less 文件都需要导出 CSS 文件吗？
                        base.less, common.less 等都不需要导出
                2.语法：
                    在 less 文件第一行添加: // out: false
    5.vw/vh：
        1.简介：
            相对单位
            相对视口的尺寸计算结果
            vw: viewport width
                1vw = 1/100 视口宽度
            vh: viewport height
                1vh = 1/100 视口高度
        2.vw 单位尺寸：
            1.确定设计稿对应的 vw 尺寸(1/100 视口宽度)
                查看设计稿宽度 -> 确定参考设备宽度(视口宽度) - > 确定 vw 尺寸(1/100 视口宽度)
            2.vw 单位的尺寸 = px 单位数值 / (1/100 视口宽度)
        3.vh 单位尺寸：
            1.确定设计稿对应的 vh 尺寸(1/100 视口高度)
                查看设计稿高度 -> 确定参考设备高度(视口高度) - > 确定 vh 尺寸(1/100 视口高度)
            2.vh 单位的尺寸 = px 单位数值 / (1/100 视口高度)
5.响应式：
    1.目标：
        了解响应式网页特点，能够使用 BootStrap 框架
    2.媒体查询：
        1.目标：
            能够根据设备宽度的变化，设置差异化样式
        2.开发常用写法：
            1.媒体特性常用写法：
                max-width: 从大到小书写
                min-width: 从小到大书写
            2.完整写法：
                @media 关键词 媒体类型 and (媒体特征) {
                    css 代码
                }
                关键词：
                    and: 用来判断多个条件
                    only: 用来判断单个条件
                    not: 取反
                媒体类型：
                    媒体是用来区分设备类型的，如屏幕设备、打印设备等，其中手机、电脑、平板都属于屏幕设备
                    screen: 带屏幕的设备
                    print: 打印浏览模式
                    speech: 屏幕阅读模式
                    all: 默认值，包括以上 3 种情形
                媒体特征：
                    媒体特性主要用来描述媒体类型的具体特征，如当前屏幕的宽高、分辨率、横屏或竖屏等
                    width、height: 视口的宽和高
                    max-width、max-height: 视口最大宽或高
                    min-width、min-height: 视口最小宽或高
                    orientation: 屏幕方向
                        portrait: 竖屏
                        landscape: 横屏
        3.外链式 CSS 引入：
            <link rel="stylesheet" href="./xxx.css" media="逻辑符 媒体类型 and (媒体特性)">
    3.BootStrap：
        参见 BootStrap 项目
```

# BFC 和 IFC 的理解（布局）

## BFC

BFC（Block Formatting Context）叫做 “块级格式化上下文"

布局规则如下：

1. 内部的盒子会在垂直方向，一个个地放置
2. 盒子垂直方向的距离由 margin 决定， 属于同一个 BFC 的两个相邻 Box 的上下 margin 会发生重叠
3. 每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此
4. BFC 的区域不会与 float 重叠
5. BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此
6. 计算 BFC 的高度时，浮动元素也参与计算

介绍过了 BFC 的布局规范，再来说说哪些元素会产生 BFC。

1. 根元素；
2. float 的属性不为 none
3. position 为 absolute 或 fixed
4. display 为 flex 或 inline-block 或 table-cell 或 table-caption
5. overflow 不为 visible

## IFC

IFC（inline Formatting Context）叫做 “行级格式化上下”

局规则如下：

1. 内部的盒子会在水平方向，一个个地放置
2. IFC 的高度，由里面最高盒子的高度决定
3. 当一行不够放置的时候会自动切换到下一行

# iconfont 批量导入购物车

因为没有批量导入购物车，所以一般情况下需要一个一个去点，太浪费时间，那么请在控制台输入以下代码，批量导入：

```js
const icons = document.querySelectorAll('.icon-gouwuche1')
const auto_click = i => {
  if (i < icons.length) {
    setTimeout(() => {
      icons.item(i).click()
      auto_click(i + 1)
    }, 10)
  }
}
auto_click(0)
```
